# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MySerAsist.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os

import serial
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QTimer, Qt
from PyQt5.QtGui import QTextCursor
from PyQt5.QtWidgets import QFrame, QMainWindow, QStatusBar, QGridLayout, QLabel, QProgressBar, QMessageBox, QFileDialog
import serial.tools.list_ports
import time
import threading

baudrates = ['110', '300', '600', '1200',
            '2400', '4800', '9600', '14400',
            '19200', '38400', '56000', '57600',
            '115200', '128000', '230400', '256000',
            '460800', '500000', '512000', '600000',
            '750000', '921600', '1000000', '1500000',
            '2000000']
databits = ['5', '6', '7', '8']
stopbits = ['1', '1.5', '2']
checkbits = ['N', 'O', 'E', 'M', 'S']

sr_select = ['', '读取文件', '发送文件']

class Serial_window(object):
    def __init__(self):
        self.ser_working = False
        # self.ser_thread = ser_recvthread(self.ser_recv)
        # self.ser_thread_working = False

        self.ser_mutex = threading.Lock()
        self.sendtmr = QTimer()
        self.sendtmr.timeout.connect(self.ser_senddata)

        self.recvtmr = QTimer()
        self.recvtmr.timeout.connect(self.ser_recv)

        self.sendfile_tmr = QTimer()
        self.sendfile_tmr.timeout.connect(self.ser_send_progerss)
        self.is_sendfile = False

        self.ser = serial.Serial()
        # self.ser.close()
        self.ser_recv_datalen = 0
        self.ser_send_datalen = 0
        self.read_data_file = False

    def window_clear(self):
        # serial window
        self.sendtmr.stop()
        self.sendfile_tmr.stop()
        # self.ser_thread.stop()
        self.recvtmr.stop()
        self.ser.close()
        self.sfile.close()
        self.rfile.close()

    def setupUi(self, frame, width):
        """
            串口程序UI布局
        """
        # 第二个布局
        main_frame2 = QMainWindow()
        frame2_bar = QStatusBar()
        frame2_bar.setObjectName("frame2_bar")
        main_frame2.setStatusBar(frame2_bar)
        frame2_bar.showMessage("欢迎进入串口小工具")

        self.frame = frame

        self.custom_frame = QFrame(main_frame2)
        self.custom_frame.setGeometry(0, 0, width, frame.height() - 25)
        self.custom_frame.setFrameShape(QFrame.Panel)
        self.custom_frame.setFrameShadow(QFrame.Raised)

        self.gridLayout = QGridLayout(self.custom_frame)
        self.gridLayout.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.ser_databit = QtWidgets.QComboBox(self.custom_frame)
        self.ser_databit.setObjectName("ser_databit")
        self.gridLayout.addWidget(self.ser_databit, 5, 1, 1, 1)
        self.label_4 = QtWidgets.QLabel(self.custom_frame)
        self.label_4.setObjectName("label_4")
        self.gridLayout.addWidget(self.label_4, 6, 0, 1, 1)
        self.label_5 = QtWidgets.QLabel(self.custom_frame)
        self.label_5.setObjectName("label_5")
        self.gridLayout.addWidget(self.label_5, 7, 0, 1, 1)
        self.ser_display_lineedit = QtWidgets.QLineEdit(self.custom_frame)
        self.ser_display_lineedit.setObjectName("ser_display")
        self.gridLayout.addWidget(self.ser_display_lineedit, 6, 2, 1, 4)
        self.ser_refresh = QtWidgets.QPushButton(self.custom_frame)
        self.ser_refresh.setObjectName("ser_refresh")
        self.ser_refresh.clicked.connect(self.serial_update)
        self.gridLayout.addWidget(self.ser_refresh, 1, 3, 1, 1)
        self.ser_stopbit = QtWidgets.QComboBox(self.custom_frame)
        self.ser_stopbit.setObjectName("ser_stopbit")
        self.gridLayout.addWidget(self.ser_stopbit, 6, 1, 1, 1)
        self.ser_sendtimer = QtWidgets.QCheckBox(self.custom_frame)
        self.ser_sendtimer.setObjectName("ser_sendtimer")
        self.ser_sendtimer.stateChanged.connect(self.sendtmr_switch)
        self.gridLayout.addWidget(self.ser_sendtimer, 4, 2, 1, 1)
        self.ser_checkbit = QtWidgets.QComboBox(self.custom_frame)
        self.ser_checkbit.setObjectName("ser_checkbit")
        self.gridLayout.addWidget(self.ser_checkbit, 7, 1, 1, 1)
        self.ser_hex_display = QtWidgets.QCheckBox(self.custom_frame)
        self.ser_hex_display.setObjectName("ser_hex_display")
        self.ser_hex_display.stateChanged.connect(self.rdata2hex)
        self.gridLayout.addWidget(self.ser_hex_display, 1, 4, 1, 2)
        self.label_7 = QtWidgets.QLabel(self.custom_frame)
        self.label_7.setObjectName("label_7")
        self.gridLayout.addWidget(self.label_7, 5, 2, 1, 4)
        self.ser_num = QtWidgets.QComboBox(self.custom_frame)
        self.ser_num.setObjectName("ser_num")
        self.gridLayout.addWidget(self.ser_num, 1, 1, 1, 1)
        self.label_2 = QtWidgets.QLabel(self.custom_frame)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 4, 0, 1, 1)
        self.label_6 = QtWidgets.QLabel(self.custom_frame)
        self.label_6.setObjectName("label_6")
        self.gridLayout.addWidget(self.label_6, 4, 4, 1, 1)
        self.ser_clearbtn = QtWidgets.QPushButton(self.custom_frame)
        self.ser_clearbtn.setObjectName("ser_clearbtn")
        self.ser_clearbtn.clicked.connect(self.ser_textedit_clear)
        self.gridLayout.addWidget(self.ser_clearbtn, 1, 6, 1, 1)
        self.textEdit = QtWidgets.QTextEdit(self.custom_frame)
        self.textEdit.setObjectName("textEdit")
        self.textEdit.setFocusPolicy(Qt.NoFocus)
        self.gridLayout.addWidget(self.textEdit, 0, 0, 1, 7)
        self.label = QtWidgets.QLabel(self.custom_frame)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 1, 0, 1, 1)
        self.ser_file_select = QtWidgets.QLineEdit(self.custom_frame)
        self.ser_file_select.setObjectName("ser_file_select")
        self.gridLayout.addWidget(self.ser_file_select, 11, 0, 1, 6)
        self.set_openbtn = QtWidgets.QPushButton(self.custom_frame)
        self.set_openbtn.setObjectName("set_openbtn")
        self.set_openbtn.clicked.connect(self.oc_serial)
        self.gridLayout.addWidget(self.set_openbtn, 1, 2, 1, 1)
        self.ser_sendbtn = QtWidgets.QPushButton(self.custom_frame)
        self.ser_sendbtn.setObjectName("ser_sendbtn")
        self.ser_sendbtn.setEnabled(False)
        self.ser_sendbtn.clicked.connect(self.ser_senddata)
        self.gridLayout.addWidget(self.ser_sendbtn, 6, 6, 1, 1)
        self.ser_sendtmr_time = QtWidgets.QLineEdit(self.custom_frame)
        self.ser_sendtmr_time.setEnabled(True)
        self.ser_sendtmr_time.setText('100')
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ser_sendtmr_time.sizePolicy().hasHeightForWidth())
        self.ser_sendtmr_time.setSizePolicy(sizePolicy)
        self.ser_sendtmr_time.setObjectName("ser_sendtmr_time")
        self.ser_sendtmr_time.textChanged.connect(self.sendtmr_switch)
        self.gridLayout.addWidget(self.ser_sendtmr_time, 4, 3, 1, 1)
        self.ser_bdrate = QtWidgets.QComboBox(self.custom_frame)
        self.ser_bdrate.setObjectName("ser_bdrate")
        self.gridLayout.addWidget(self.ser_bdrate, 4, 1, 1, 1)
        self.ser_sendhex = QtWidgets.QCheckBox(self.custom_frame)
        self.ser_sendhex.setObjectName("ser_sendhex")
        self.ser_sendhex.stateChanged.connect(self.sdata2hex)
        self.gridLayout.addWidget(self.ser_sendhex, 7, 2, 1, 1)
        self.label_3 = QtWidgets.QLabel(self.custom_frame)
        self.label_3.setObjectName("label_3")
        self.gridLayout.addWidget(self.label_3, 5, 0, 1, 1)
        self.ser_send_filebtn = QtWidgets.QPushButton(self.custom_frame)
        self.ser_send_filebtn.setObjectName("ser_send_filebtn")
        self.ser_send_filebtn.setEnabled(False)
        self.ser_send_filebtn.clicked.connect(self.ser_rw_sendfile_btn_clicked)
        self.gridLayout.addWidget(self.ser_send_filebtn, 10, 6, 1, 1)
        self.ser_rw_combo = QtWidgets.QComboBox(self.custom_frame)
        self.ser_rw_combo.setObjectName("ser_rw_combo")
        self.ser_rw_combo.setEnabled(False)
        self.ser_rw_combo.activated[str].connect(self.ser_rw_combo_changed)
        self.gridLayout.addWidget(self.ser_rw_combo, 10, 5, 1, 1)
        self.ser_rw_checkbox = QtWidgets.QCheckBox(self.custom_frame)
        self.ser_rw_checkbox.setObjectName("ser_rw_checkbox")
        self.ser_rw_checkbox.stateChanged.connect(self.send_file_select)
        self.gridLayout.addWidget(self.ser_rw_checkbox, 10, 0, 1, 1)
        self.ser_file_select_btn = QtWidgets.QPushButton(self.custom_frame)
        self.ser_file_select_btn.setObjectName("ser_file_select_btn")
        self.ser_file_select_btn.clicked.connect(self.ser_rw_selectbtn_clicked)
        self.gridLayout.addWidget(self.ser_file_select_btn, 11, 6, 1, 1)
        self.send_with_enter = QtWidgets.QCheckBox(self.custom_frame)
        self.send_with_enter.setObjectName("send_with_enter")
        self.gridLayout.addWidget(self.send_with_enter, 4, 5, 1, 1)

        self.sendfile_time_lable = QLabel(self.custom_frame)
        self.sendfile_time_lable.setText('文件发送时长: 0ms' )
        self.sendfile_time_lable.setVisible(False)
        self.sendfile_time_lable.setGeometry(100, frame.height(), 50, 25)
        frame2_bar.addPermanentWidget(self.sendfile_time_lable)

        self.send_bar = QProgressBar(self.custom_frame)
        self.send_bar.setGeometry(50, frame.height(), 50, 20)
        self.send_bar.setVisible(False)
        frame2_bar.addPermanentWidget(self.send_bar)

        self.sr_lable = QLabel(self.custom_frame)
        self.sr_lable.setText('S:       R:      ')
        self.sr_lable.setGeometry(100, frame.height(), 50, 25)
        frame2_bar.addPermanentWidget(self.sr_lable)

        self.ser_bdrate.addItems(baudrates)
        self.ser_bdrate.setCurrentIndex(12)
        self.ser_databit.addItems(databits)
        self.ser_databit.setCurrentIndex(3)
        self.ser_stopbit.addItems(stopbits)
        self.ser_checkbit.addItems(checkbits)
        self.ser_rw_combo.addItems(sr_select)

        self.retranslateUi()

        frame2_bar_frame = QFrame(main_frame2)
        frame2_bar_frame.setGeometry(0, frame.height(), width, 25)

        return main_frame2, self.custom_frame


    def retranslateUi(self):
        self.label_4.setText("停止位")
        self.label_5.setText("校验位")
        self.ser_refresh.setText("刷新串口")
        self.ser_sendtimer.setText("定时发送")
        self.ser_hex_display.setText("Hex显示")
        self.label_7.setText("字符串输入框")
        self.label_2.setText("波特率")
        self.label_6.setText("ms/次")
        self.ser_clearbtn.setText("清除窗口")
        self.label.setText("串口号")
        self.set_openbtn.setText("打开串口")
        self.ser_sendbtn.setText("发送")
        self.ser_sendhex.setText("Hex发送")
        self.label_3.setText("数据位")
        self.ser_send_filebtn.setText("读写文件")
        self.ser_rw_checkbox.setText("选中读写文件")
        self.ser_file_select_btn.setText("...")
        self.send_with_enter.setText("加回车换行")

    def oc_serial(self):
        """
            打开关闭串口
        """
        if self.ser_working == False:
            try:
                self.ser.port = self.ser_num.currentText()
                self.ser.baudrate = int(self.ser_bdrate.currentText())
                self.ser.bytesize = int(self.ser_databit.currentText())
                self.ser.stopbits = int(self.ser_stopbit.currentText())
                self.ser.parity = self.ser_checkbit.currentText()
                # self.ser = serial.Serial(self.ser_num.currentText(), int(self.ser_bdrate.currentText()))
                self.ser.open()
            except:
                QMessageBox.critical(self.frame, '串口打开失败', '没有可用的串口或当前串口被占用')
                return None
            self.ser_working = True
            self.set_openbtn.setText("关闭串口")
            if self.ser_rw_checkbox.isChecked() == False:
                self.ser_sendbtn.setEnabled(True)
            else:
                self.ser_send_filebtn.setEnabled(True)
            self.sendtmr_switch()
            # if not self.ser_thread_working:
            #     self.ser_thread_working = True
            #     self.ser_thread.start()
            # self.ser_thread.resume()
            self.recvtmr.start(0.001)
        else:
            self.recvtmr.stop()
            # self.ser_thread.pause()
            self.sendfile_tmr.stop()
            try:
                self.ser.close()
            except:
                QMessageBox.critical(self.frame, '串口关闭失败', '串口关闭失败')
                return None

            if self.is_sendfile:
                self.sfile.close()
                self.is_sendfile = False
                self.file_send_len = 0
                self.snd_bar_value = 0
                self.ser_send_filebtn.setText('发送文件')
                self.ser_file_select.setEnabled(True)
            self.set_openbtn.setText("打开串口")
            self.ser_sendbtn.setEnabled(False)
            self.ser_send_filebtn.setEnabled(False)
            self.ser_working = False

    def serial_update(self):
        """
            更新串口端口显示
        """
        self.ser_num.clear()
        plist = list(serial.tools.list_ports.comports())
        for i in range(0, len(plist)):
            plist_0 = list(plist[i])
            #print('串口号：', list(plist[i]),str(plist_0[0]))
            self.ser_num.addItem(plist_0[0])
        if self.ser.is_open:
            self.oc_serial()

    def sendtmr_switch(self):
        """
            发送数据定时器开关
        """
        if self.ser_sendtimer.isChecked():
            self.sendtmr.stop()
            try:
                time_msec = int(self.ser_sendtmr_time.text())
            except:
                QMessageBox.critical(self.frame, '发送失败', '发送时间为空')
                return
            try:
                if time_msec == 0:
                    time_msec = 1
                    self.ser_sendtmr_time.setText('1')
                self.sendtmr.start(time_msec)
                if self.ser.is_open == False:
                    QMessageBox.critical(self.frame, '发送失败', '串口未打开')
            except:
                # QMessageBox.critical('定时发送失败', '超时时间超过预期')
                return
        else:
            self.sendtmr.stop()

    def ser_senddata(self):
        """
           发送数据回调
       """
        if self.ser.is_open == False:
            # self.sendtmr.stop()
            return
        if self.send_with_enter.isChecked():
            data = self.ser_display_lineedit.text() + '\n'
        else:
            data = self.ser_display_lineedit.text()
        self.ser.write(data.encode())
        self.ser_send_datalen += len(data)
        self.sr_lable.setText('S: %d    R: %d   ' % (self.ser_send_datalen, self.ser_recv_datalen))

    def ser_recv(self):
        """
                串口数据接受回调函数，同时将数据显示到textEdit中
        """
        self.ser_mutex.acquire()
        try:
            ser_datalen = self.ser.inWaiting()
        except:
            self.serial_update()
            self.recvtmr.stop()
            # self.ser_thread.pause()
            self.sendfile_tmr.stop()
            try:
                self.ser.close()
            except:
                QMessageBox.critical(self.frame, '串口关闭失败', '串口关闭失败')
                return None

            if self.is_sendfile:
                self.sfile.close()
                self.is_sendfile = False
                self.file_send_len = 0
                self.snd_bar_value = 0
                self.ser_send_filebtn.setText('发送文件')
                self.ser_file_select.setEnabled(True)
            self.set_openbtn.setText("打开串口")
            self.ser_sendbtn.setEnabled(False)
            self.ser_send_filebtn.setEnabled(False)
            self.ser_working = False
            self.ser_mutex.release()
            return None

        if(ser_datalen):
            data_recv = self.ser.read(ser_datalen)
            #print(data_recv, len(data_recv), ser_datalen)
            # 串口接收到的字符串为b'123',要转化成unicode字符串才能输出到窗口中去
            self.ser_recv_datalen += ser_datalen
            self.textEdit.moveCursor(QTextCursor.End)
            if self.ser_hex_display.isChecked():
                out_s = ''
                for i in range(0, len(data_recv)):
                    out_s = out_s + '{:02X}'.format(data_recv[i]) + ' '
                self.textEdit.insertPlainText(out_s)
            else:
                self.textEdit.insertPlainText(data_recv.decode('iso-8859-1'))
            self.sr_lable.setText('S: %d    R: %d   ' % (self.ser_send_datalen, self.ser_recv_datalen))
            if self.read_data_file:
                if data_recv != '':
                    try:
                        self.rfile.write(data_recv)
                    except:
                        self.read_data_file = False
                        self.rfile.close()
                        self.ser_send_filebtn.setText('读取文件')
                        QMessageBox.critical(self.frame, '读取错误', '读取写入文件出错')
                else:
                    self.read_data_file = False
                    self.rfile.close()
                    self.ser_send_filebtn.setText('读取文件')
                    QMessageBox.critical(self.frame, '接收成功', '读取写入文件成功')
        self.ser_mutex.release()

    def rdata2hex(self):
        """
                接收数据转化为16进制显示
        """
        data_text = self.textEdit.toPlainText()
        if self.ser_hex_display.isChecked():
            pass
            # out_bytes = bytes.fromhex(data_text.replace('\r', '').replace('\n', ''))#self.data2hex(data_text)
            # #print(out_bytes[0])
            # #out_s = ''.join(['%02x ' % b for b in out_bytes])
            # out_s = self.data2hex(out_bytes)
            # self.textEdit.clear()
            # self.textEdit.insertPlainText(out_s)
        else:
            pass
            #self.textEdit.insertPlainText(data_text.decode('iso-8859-1'))

    def sdata2hex(self):
        """
            发送数据转化为16进制发送
            功能未完善
        """
        if self.ser_sendhex.isChecked():
            data_temp = self.ser_display_lineedit.text()
            data = ''
            for i in range(0, len(data_temp)):
                try:
                    data = data + '%02x' %(int(data_temp[i])) + ' '
                except:
                    pass
            self.ser_display_lineedit.setText(data)


    def data2hex(self, text):
        """
            textEdit内容转化为hex格式数据显示
            功能未完善
        """
        high_hex = 30
        low_hex = 30
        result = ''
        for i in range(len(text)):
            high_hex = text[i]//10
            low_hex = text[i]%10
            result += str(high_hex) + ' ' + str(low_hex) + ' '
        return result

    def ser_textedit_clear(self):
        """
           清空textEdit内容
       """
        self.textEdit.clear()
        self.ser_send_datalen = 0
        self.ser_recv_datalen = 0
        self.sr_lable.setText('S: %d    R: %d   ' % (self.ser_send_datalen, self.ser_recv_datalen))
        #self.textEdit.moveCursor(QTextCursor.End)

    def send_file_select(self):
        """
           单选框：开启读写文件功能，同时关闭定时发送功能和手动发送数据的功能
       """
        if self.ser_rw_checkbox.isChecked():
            self.sendtmr.stop()
            self.ser_sendtimer.setCheckState(False)
            self.ser_sendtimer.setEnabled(False)
            self.ser_sendbtn.setEnabled(False)
            self.ser_rw_combo.setEnabled(True)
            if self.ser.is_open:
                self.ser_send_filebtn.setEnabled(True)
        else:
            self.ser_sendtimer.setEnabled(True)
            self.ser_sendbtn.setEnabled(True)
            self.ser_rw_combo.setEnabled(False)
            self.ser_send_filebtn.setEnabled(False)
            self.send_bar.setVisible(False)
            self.sendfile_time_lable.setVisible(False)
        self.read_data_file = False

    def ser_rw_combo_changed(self, str):
        """
            下拉框：选择发送文件或读取文件
        """
        if self.ser_rw_combo.currentText() != '':
            self.ser_send_filebtn.setText(str)
        else:
            self.ser_send_filebtn.setText('读写文件')
            self.send_bar.setVisible(False)
            self.sendfile_time_lable.setVisible(False)

    def ser_rw_sendfile_btn_clicked(self):
        """
            发送文件按键回调：点击开始发送文件
        """
        if self.ser_rw_combo.currentText() == '发送文件':
            self.read_data_file = False
            if self.is_sendfile == False:
                self.is_sendfile = True
                self.file_send_len = 0
                self.snd_bar_value = 0
                self.sendfile_time = 0

                self.ser_send_filebtn.setText('结束发送')
                # with open(self.ser_file_select.text()) as sfile:
                #     for data in sfile.readlines():
                #         self.ser.write(data.encode())
                #         self.file_send_len += len(data)
                #         self.snd_bar_value = self.file_send_len *100// self.send_file_size
                #         if file_data == '':
                #             self.snd_bar_value = 99
                #         self.send_bar.setValue(self.snd_bar_value)
                #         print(self.file_send_len, self.send_file_size)
                try:
                    if self.ser_file_select.text().endswith('bin'):
                        self.sfile = open(self.ser_file_select.text(), 'rb')
                    else:
                        self.sfile = open(self.ser_file_select.text(), 'r')
                except:
                    self.is_sendfile = False
                    self.file_send_len = 0
                    self.snd_bar_value = 0
                    self.ser_send_filebtn.setText('发送文件')
                    QMessageBox.critical(self.frame, '文件发送失败', '文件不存在或已被其他程序打开')
                    return
                self.ser_rw_combo.setEnabled(False)
                self.send_bar.setVisible(True)
                self.ser_file_select_btn.setEnabled(False)
                self.sendfile_time_lable.setVisible(True)
                self.sendfile_tmr.start(100)
            else:
                self.is_sendfile = False
                self.file_send_len = 0
                self.snd_bar_value = 0
                self.sendfile_tmr.stop()
                self.sfile.close()
                self.ser_send_filebtn.setText('发送文件')
                self.ser_rw_combo.setEnabled(True)
                self.ser_file_select.setEnabled(True)
                self.ser_file_select_btn.setEnabled(True)
        elif self.ser_rw_combo.currentText() == '读取文件':
            self.send_bar.setVisible(False)
            self.sendfile_time_lable.setVisible(False)
            if self.read_data_file == False:
                self.read_data_file = True
                self.ser_send_filebtn.setText('停止')
                self.rfile = open('read_file_%04d%02d%02d%02d%02d%02d.bin' %(
                                time.localtime().tm_year, time.localtime().tm_mon, time.localtime().tm_mday,
                                time.localtime().tm_hour, time.localtime().tm_min, time.localtime().tm_sec), 'wb')
            else:
                self.read_data_file = False
                self.ser_send_filebtn.setText('读取文件')
                self.rfile.close()
        else:
            self.send_bar.setVisible(False)
            self.sendfile_time_lable.setVisible(False)
            self.ser_send_filebtn.setText('读写文件')
            self.read_data_file = False

    def ser_rw_selectbtn_clicked(self):
        """
            点击选择要发送的文件
        """
        file, ok1 = QFileDialog.getOpenFileName(self.frame,
                                                "文件选择",
                                                "./",
                                                "All Files (*);;Txt Files (.txt);;Bin Files (.bin)")
        if ok1:
            self.ser_file_select.setText(file)
            self.send_file_size = os.path.getsize(file)

    def ser_send_progerss(self):
        """
           文件发送定时器回调函数
       """
        try:
            # if self.ser_file_select.text(). endswith('bin'):
            #     pass
            # else:
                if self.send_file_size < 1024:
                    file_data = self.sfile.read(self.send_file_size)
                else:
                    file_data = self.sfile.read(1024)
        except:
            self.is_sendfile = False
            self.file_send_len = 0
            self.snd_bar_value = 0
            self.sendfile_tmr.stop()
            self.ser_send_filebtn.setText('发送文件')
            self.send_bar.setVisible(False)
            self.sendfile_time_lable.setVisible(False)
            self.ser_file_select_btn.setEnabled(True)
            self.ser_rw_combo.setEnabled(True)
            QMessageBox.critical(self.frame, '文件发送失败', '文件不存在或已被其他程序打开')
            return
        self.ser_file_select.setEnabled(False)
        if self.ser_file_select.text().endswith('bin'):
            self.ser.write(file_data)
        else:
            self.ser.write(file_data.encode())
        self.file_send_len += len(file_data)
        self.snd_bar_value = self.file_send_len * 100 // self.send_file_size
        self.send_bar.setValue(self.snd_bar_value)
        self.sendfile_time += 100
        self.sendfile_time_lable.setText('文件发送时长: %dms' % (self.sendfile_time))
        self.ser_send_datalen += len(file_data)
        self.sr_lable.setText('S: %d    R: %d   ' % (self.ser_send_datalen, self.ser_recv_datalen))
        if file_data == '' or self.snd_bar_value >= 100:
            self.snd_bar_value = 100
            self.ser_file_select.setEnabled(True)
            self.sendfile_tmr.stop()
            self.sfile.close()
            self.ser_send_filebtn.setText('发送文件')
            self.ser_file_select_btn.setEnabled(True)
            self.ser_rw_combo.setEnabled(True)
            QMessageBox.about(self.frame, '发送完成', '文件发送成功')

        # print(self.file_send_len, self.send_file_size)

# 继承threading.Thread
'''
通过线程读取串口数据在速度比较慢的情况下可以完美工作，
但是在快速的接收数据时会出现卡死的情况，也许是线程读取部分的逻辑没有弄好，
所以我换成了2ms定时读取
'''
class ser_recvthread(threading.Thread):
    def __init__(self, func):
        super(ser_recvthread, self).__init__()
        self.func = func
        self.__flag = threading.Event()  # 用于暂停线程的标识
        self.__flag.set()  # 设置为True
        self.__running = threading.Event()  # 用于停止线程的标识
        self.__running.set()  # 将running设置为True

    def run(self):
        while self.__running.isSet():
            self.__flag.wait()  # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回
            self.func()

    def pause(self):
        self.__flag.clear()  # 设置为False, 让线程阻塞

    def resume(self):
        self.__flag.set()  # 设置为True, 让线程停止阻塞

    def stop(self):
        self.__flag.clear()
        self.__running.clear()  # 设置为False